<!DOCTYPE html>
<html>
	<head>
		<title>缓存</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<script src="js/inc.js"></script>
	</head>
	<body>
		<fieldset>
			<legend>缓存</legend>
			<ol>
				<li>
					<h3 class="title_h2">缓存介绍</h3>
					在Soter里面，缓存数据用户可以选择使用：文件缓存，apc缓存，memcache缓存，memcached缓存，redis缓存，mongodb缓存。
					<br>如果这些还是无法满足你的需求，支持自定义缓存处理类，按着你自己的方式缓存数据，下面会详细介绍。
				</li>
				<li>
					<h3 class="title_h2">缓存配置</h3>
					数据库缓存操作使用的是入口文件里面配置的程序使用的缓存处理类，配置位于入口文件index.php里面，
					<br>在入口文件里面我们看到下面这个一行：
					<pre class="brush:php">
				//设置缓存类型
				->setCacheHandle(new Soter_Cache_File(SOTER_APP_PATH . 'storage/cache/'))
					</pre>
					Soter内置的缓存类有：
					<br>1.<b>Soter_Cache_Apc</b>       
					<br>使用方法：->setCacheHandle(new Soter_Cache_Apc('cache_apc'))
					<br>使用配置文件是：cache_apc.php
					<br>2.<b>Soter_Cache_Memcached</b>   
					<br>使用方法：->setCacheHandle(new Soter_Cache_Apc('cache_memcached'))
					<br>使用配置文件是：cache_memcached.php
					<br>3.<b>Soter_Cache_Memcache</b>    
					<br>使用方法：->setCacheHandle(new Soter_Cache_Apc('cache_memcache'))
					<br>使用配置文件是：cache_memcache.php
					<br>4.<b>Soter_Cache_Redis</b>       
					<br>使用方法：->setCacheHandle(new Soter_Cache_Apc('cache_redis'))
					<br>使用配置文件是：cache_redis.php
					<br>5.<b>Soter_Cache_Mongodb</b>     
					<br>使用方法：->setCacheHandle(new Soter_Cache_Apc('cache_mongodb'))
					<br>使用配置文件是：cache_mongodb.php
					<br>6.<b>Soter_Cache_File</b>   
					<br>使用方法：->setCacheHandle(new Soter_Cache_File(SOTER_APP_PATH . 'storage/cache/''))
					<br>它会把缓存数据写到<code>application/storage/cache/</code>目录下面。
				</li>
				<li><h3 class="title_h2">使用缓存</h3>
					当我们安着上面的操作配置了缓存处理类之后，我们就可以用下面的方法操作缓存数据了。
					<h3 class="title_h3">1.设置缓存</h3>
					<pre class="brush:php">
						 Sr::cache()->set($key, $value, $cacheTime)
					</pre>
					参数1：缓存key。
					<br>参数2：缓存的数据。
					<br>参数3：缓存的时间，单位秒。比如：缓存60秒。$cacheTime就是：60。
					<br>返回值：成功：true，失败：false。
					<h3 class="title_h3">2.获取缓存</h3>
					<pre class="brush:php">
						 Sr::cache()->get($key)
					</pre>
					参数1：缓存key。
					<br>返回值：成功：缓存数据，失败：NULL。
					<h3 class="title_h3">3.删除缓存</h3>
					<pre class="brush:php">
						 Sr::cache()->delete($key)
					</pre>
					参数1：缓存key。
					<br>返回值：成功：true，失败：false。
					<h3 class="title_h3">4.清空缓存</h3>
					<pre class="brush:php">
						 Sr::cache()->clean()
					</pre>
					返回值：成功：true，失败：false。
				</li>
				<li><h3 class="title_h2">自定义缓存处理类</h3>
					如果要把自己的类作为缓存类使用，那么必须实现缓存接口<code>Soter_Cache</code>，上面的几个Soter内置的缓存类都实现了这个接口。
					<br>现在我们看一下这个接口的定义代码：
					<pre class="brush:php">
						interface Soter_Cache {

							public function set($key, $value, $cacheTime);

							public function get($key);

							public function delete($key);

							public function clean();
						}
					</pre>
					可以看到接口定义了几个标准的方法用于操作缓存数据。
					<br>下面对这几个方法的实现详细说明一下：
					<br>1.<b>set($key, $value, $cacheTime)</b>
					<br>作用：设置缓存
					<br>返回：成功返回true失败返回false
					<br>参数一：缓存的key
					<br>参数二：缓存数据
					<br>参数三：“缓存时间”是0的时候，缓存不过期。
					<br>2.<b>get()</b>
					<br>作用：获取缓存
					<br>返回：成功返回数据，失败返回 NULL
					<br>3.<b>delete($key)</b>
					<br>作用：删除一个缓存
					<br>返回：成功返回true失败返回false
					<br>参数一：缓存的key
					<br>4.<b>clean()</b>
					<br>作用：清空所有缓存
					<br>返回：成功返回true失败返回false
					<br>知道了接口方法的作用，我们就可以开始自定义类处理缓存了。
					<br>现在我们实现一个简单的缓存处理类，简单的显示数据，了解一下过程。
					<br>1.新建一个文件<code>applcation/classes/Cache/MyCacheHandle.php</code>
					<br>2.输入下面代码：
					<pre class="brush:php">
						&lt;?php
						class Cache_MyCacheHandle implements Soter_Cache{
							public function set($key, $value, $cacheTime){
								echo 'set cache [ '.$key.':'.$value.' ]('.$cacheTime.' ms)';
								return true;
							}
							public function get($key){
								echo 'get cache [ '.$key.' ]';
								return true;
							}
							public function delete($key){
								echo 'delete cache [ '.$key.' ]';
								return true;
							}
							public function clean(){
								echo 'clean cache';
								return true;
							}
						}
					</pre>
					3.修改配置，设置我们自己的缓存处理类<b>Cache_MyCacheHandle</b>。
					<pre class="brush:php">
						->setCacheHandle(new Cache_MyCacheHandle())
					</pre>
					4.为了测试我们设置的缓存处理类有没有生效，我们在控制器里面调用缓存的几个方法看看没有预期的输出。
					<br>我们在任意的控制器方法里面写上下面的测试代码：
					<pre class="brush:php">
						Sr::cache()->set('testKey','testValue',1000);
						Sr::cache()->get('testKey');
						Sr::cache()->delete('testKey');
						Sr::cache()->clean();
					</pre>
					最后在浏览器我们访问一下这个控制器方法看一下是否达到预期输出。
			</ol>
		</fieldset>
		<script src="js/inc.foot.js"></script>
	</body>
</html>
