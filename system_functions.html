<!DOCTYPE html>
<html>
        <head>
                <title>系统函数</title>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <script src="js/inc.js"></script>
        </head>
        <body>
                <fieldset>
                        <legend>系统函数</legend>
                        <ol>
                                <li>
                                        <h2 class="title_h2">打印变量内容</h2>
                                        通过Sr::dump()方法，打印变量内容，参数和var_dump一样，但是比var_dump好看让我们更容易找出问题。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                $a = array('a'=>1, 'b'=>2, 'c'=>3);
                                                Sr::dump($a);
                                                //上面将会输出：
                                                /*
                                                array(3) {
                                                        ["a"]=>
                                                        int(1)
                                                        ["b"]=>
                                                        int(2)
                                                        ["c"]=>
                                                        int(3)
                                                }
                                                */
                                        </pre>

                                </li>
				<li>
                                        <h2 class="title_h2">分页条</h2>
					通过Sr::page($total, $page, $pagesize, $url,$order=array(1,2,3,4,5,6),$a_count=10)方法，可以方便的产生一个分页条。
					<br>一个标准的分页条由下面6部分组成，如下：
					<br><img src="images/page.jpg"/>
					<br><b class="text_strong">参数说明：</b>
					<br><b>$total</b>    一共多少记录
					<br><b>$page</b>     当前是第几页
					<br><b>$pagesize</b> 每页多少
					<br><b>$url</b>      url是什么，url里面的{page}会被替换成页码
					<br><b>$order</b>    分页条的组成，是一个数组,可以按着1-6的序号,选择分页条组成部分和每个部分的顺序
					<br><b>$a_count</b>  分页条中a页码链接的总数量(也就是上面第4部分),不包含当前页的a标签，默认10个。
					<br><b class="text_strong">示例：</b>
					<pre class="brush:php">
						echo Sr::page(100,3,10,'?article/list/{page}',array(3,4,5,1,2,6),10);
					</pre>
					示例将输出:
					<br><img src="images/page_demo.jpg"/>
					<br><b class="text_strong">提示：</b>
					<br>上面的6部分，每部分被一个span包围，span都有对应的class，便于css控制。
					<br>每部分span的对应class如下：
					<br>1:page_total
					<br>2:page_cur
					<br>3:page_bar_prefix
					<br>4:page_cur_page
					<br>5:page_bar_subfix
					<br>6:page_input_num
					<br><b>另外：</b>
					<br>”转到“的class是:page_btn_go
				</li>
                                <li>
                                        <h2 class="title_h2">realpath的改良版</h2>
                                        通过Sr::realPath()方法，文件或者目录不存在的时候也可以返回正确的路径。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                Sr::realPath('file.php', false);
                                                //第一个参数 必填：文件或者目录
                                                //第二个参数 选填：如果为true的话，最后多加/符号，默认是false
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">验证是否用命令行</h2>
                                        通过Sr::isCli()方法，验证是否用命令行。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                Sr::dump(Sr::isCli());
                                                //如果用命令行就返回true，否则返回false
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">过滤xss注入</h2>
                                        通过Sr::xssClean()方法，过滤xss注入。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                $var = array('&lt;test');
                                                Sr::xssClean($var);
                                                //$var:可以数组，也可以字符串
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">获取服务器的hostname</h2>
                                        通过Sr::hostname()方法，获取服务器的hostname。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                echo Sr::hostname();
                                                //输出当前服务器的hostname
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">获取服务器的ip</h2>
                                        通过Sr::serverIp()方法，获取服务器的ip。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                echo Sr::serverIp();
                                                //输出当前服务器的ip
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">获取客户端的ip</h2>
                                        通过Sr::clientIp()方法，获取客户端的ip。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                echo Sr::clientIp();
                                                //输出当前客户端的ip
                                        </pre>
					<b class="text_strong">提示：</b>
					<br>入口文件里面我们可以发现下面的配置：
					<pre class="brush:php">
                                                ->setBackendServerIpWhitelist(array('192.168.2.2'))
                                        </pre>
					如果服务器是ngix之类代理转发请求到后端apache运行的PHP。
					<br>那么这里应该设置信任的nginx所在服务器的ip。
					<br>nginx里面应该设置 X_FORWARDED_FOR server变量来表示真实的客户端IP。
					<br>不然通过Sr::clientIp()是获取不到真实的客户端IP的。
					<br>参数是数组，有多个ip放入数组即可。
                                </li>
                                <li>
                                        <h2 class="title_h2">验证字符串开头</h2>
                                        通过Sr::strBeginsWith()方法，验证字符串开头。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                Sr::dump(Sr::strBeginsWith('helle world','helles'));
                                                //将会输出：false
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">验证字符串结尾</h2>
                                        通过Sr::strEndsWith()方法，验证字符串结尾。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                Sr::dump(Sr::strEndsWith('helle world','world'));
                                                //将会输出：true
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">获取IP段信息</h2>
                                        通过Sr::ipInfo()方法，传入Ip地址对Ip段地址进行处理得到相关的信息。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                Sr::dump(Sr::ipInfo('192.168.1.1/32'));                                                
                                                /*                                                
                                                上面将会输出：array(
                                                        netmask=>255.255.255.255(网络掩码)
                                                        count=>1(网络可用IP数目)
                                                        start=>192.168.1.1(可用IP开始)
                                                        end=>192.168.1.1(可用IP结束)
                                                        netaddress=>192.168.1.1(网络地址)
                                                        broadcast=>192.168.1.1(广播地址)
                                                )
                                                */

                                                echo Sr::ipInfo('192.168.1.1/32', 'netmask');
                                                //上面将会输出：255.255.255.255
                                                //我们可以看到多了个第二参数，第二参数是我们上面数组的键。
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">获取当前UNIX毫秒时间戳</h2>
                                        通过Sr::microtime()方法，获取当前UNIX毫秒时间戳。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                echo Sr::microtime();
                                                //将会输出：当前UNIX毫秒时间戳
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">删除文件夹和子文件夹</h2>
                                        通过Sr::rmdir()方法，删除文件夹和子文件夹。
                                        <br>示例如下
                                        <pre class="brush:php">
                                                //假如我们路径是E:\test底下有test.php和images文件夹
                                                Sr::rmdir('E:\test');
                                                //执行上面代码：将会删除test文件夹包括底下test.php和images文件夹

                                                //假如我们路径是E:\test2底下有test2.php和images2文件夹
                                                Sr::rmdir('E:\test2', false);
                                                //执行上面代码：将会删除test2.php和images2文件夹，保留test2文件夹
                                                //我们可以看到多了个第二参数，作用是否保留最父层文件夹，我们默认是不保留的。
                                        </pre>

                                </li>
                                <li>
                                        <h2 class="title_h2">检查数组键值是否存在</h2>
                                        通过Sr::arrayKeyExists($key, $array)方法，检查数组键值是否存在。
                                        <br>$key 必填： 键值 
                                        <br>$array 必填： 数组(支持多维数组)
                                        <br>示例如下
                                        <pre class="brush:php">
                                                //1.一维数组
                                                $key = 'a';
                                                $arr = array('a'=>1, 'b'=>2, 'c'=>3);
                                                Sr::arrayKeyExists($key, $arr);
                                                //上面将输出:true

                                                //2.多维数组
                                                Sr::arrayKeyExists('a.b.c', array('a' => array('b' => array( 'c'=> 1))));
                                                //上面将输出:true
                                        </pre>
                                </li>
                                <li>
                                        <h2 class="title_h2">获取数组的值</h2>
                                        通过Sr::arrayGet($array, $key, $default = null)方法，获取数组的值。
                                        <br>$array 必填： 数组
                                        <br>$key 必填： 键值 
                                        <br>$default 选填： 默认值 
                                        <br>示例如下
                                        <pre class="brush:php">
                                                //1.获取数组里面键值为a的值
                                                Sr::arrayGet(array('a'=>1, 'b'=>2), 'a');
                                                //上面将输出:1

                                                //2.获取数组里面键值为c的值,如果没有就输出3
                                                Sr::arrayGet(array('a'=>1, 'b'=>2), 'c', '3');
                                                //上面将输出:3
                                                //如果第三个参数没填就会输出"null"
                                        </pre>
                                </li>
				<li>
                                        <h2 class="title_h2">加密数据</h2>
                                        通过Sr::encrypt($str, $key = '', $attachKey = false)方法，可以方便安全的加密数据。
                                        <br>$str 要加密的字符串
                                        <br>$key 密钥key
                                        <br>$attachKey 　true : 假如配置文件里面设置了加密密钥$key1，那么最终加密使用的密钥是$key1+$key。
					<br>　　　　　　　false: 最终加密使用的是$key
					<br>提示：
					<br>加密使用的是DES加密算法，密钥使用的是md5($userKey)加密后32个字符结果的前8个字符。
					<br>$userKey就是用户设置的密钥。
					<br>当没有传递第二个密钥参数的时候，必须在入口文件里面设置用户密钥。
					<br>在入口文件里面可以看到下面的配置：
					<pre class="brush:php">
						/* 设置加密方法Sr::encrypt()和解密方法Sr::decrypt()使用的密钥,
						 * 只有这里设置了密钥，当不传递key的时候，这两个方法才能正常使用。
						 * 提示：这里可以使用数组指定三个环境下的密钥，还可以传递一个字符串
						 * 这个字符串就是所有环境使用的密钥。 */
						->setEncryptKey(array(
						    Sr::ENV_DEVELOPMENT => '', //开发环境密钥
						    Sr::ENV_TESTING => '', //测试环境密钥
						    Sr::ENV_PRODUCTION => ''//产品环境密钥
						))
                                        </pre>
					<b>提示：</b>
					<br><b>1.setEncryptKey()参数也可以是一个密钥字符串</b>
					<br>当是密钥字符串的时候，三个环境使用的都是传递的密钥字符串。
					比如下面这样设置，传递一个密钥字符串：
					<pre class="brush:php">
						->setEncryptKey('09q0mcru-qw4erc')
                                        </pre>
					那么加密方法Sr::encrypt()和解密方法Sr::decrypt()在开发环境、
					<br>测试环境、产品环境使用的都是密钥：09q0mcru-qw4erc
					<br><b>2.setEncryptKey()参数是数组的时候</b>
					<br>假设我们在入口文件里面配置了密钥如下：
					<pre class="brush:php">
						->setEncryptKey(array(
						    Sr::ENV_DEVELOPMENT => 'lqreqc4245mrqce', //开发环境密钥
						    Sr::ENV_TESTING => 'lqreqc4245mrqce', //测试环境密钥
						    Sr::ENV_PRODUCTION => 'vqreqceqmrqce'//产品环境密钥
						))
                                        </pre>
                                        假设当前是开发环境，使用示例如下：
                                        <pre class="brush:php">
						//1.使用入口文件设置的密钥lqreqc4245mrqce加密数据123
						Sr::encrypt('123');
						//2.使用密钥abcd加密数据123
						Sr::encrypt('123','abcd');
						//3.使用入口文件设置的密钥lqreqc4245mrqce+用户密钥99999加密数据123
						//最终加密使用的就是密钥：lqreqc4245mrqce99999
						Sr::encrypt('123','99999',true);
                                        </pre>
                                </li>
				<li>
                                        <h2 class="title_h2">解密数据</h2>
                                        通过Sr::decrypt($str, $key = '', $attachKey = false)方法，可以方便安全的解密数据。
                                        <br>$str 要解密的字符串
                                        <br>$key 密钥key
                                        <br>$attachKey 　true : 假如配置文件里面设置了解密密钥$key1，那么最终解密使用的是$key1+$key。
					<br>　　　　　　　false: 最终解密使用的是$key
					<br>提示：
					<br>解密使用的是DES解密算法，密钥使用的是md5($userKey)解密后32个字符结果的前8个字符。
					<br>$userKey就是用户设置的密钥。
					<br>当没有传递第二个密钥参数的时候，必须在入口文件里面设置用户密钥。
					<br>在入口文件里面可以看到下面的配置：
					<pre class="brush:php">
						/* 设置加密方法Sr::encrypt()和解密方法Sr::decrypt()使用的密钥,
						 * 只有这里设置了密钥，当不传递key的时候，这两个方法才能正常使用 */
						->setEncryptKey(array(
						    Sr::ENV_DEVELOPMENT => '', //开发环境密钥
						    Sr::ENV_TESTING => '', //测试环境密钥
						    Sr::ENV_PRODUCTION => ''//产品环境密钥
						))
                                        </pre>
					假设我们在入口文件里面配置了密钥如下：
					<pre class="brush:php">
						->setEncryptKey(array(
						    Sr::ENV_DEVELOPMENT => 'lqreqc4245mrqce', //开发环境密钥
						    Sr::ENV_TESTING => 'fad4245mrqadfad', //测试环境密钥
						    Sr::ENV_PRODUCTION => 'vqreqceqmrqce'//产品环境密钥
						))
                                        </pre>
                                        假设当前是开发环境，使用示例如下：
                                        <pre class="brush:php">
						//1.使用入口文件设置的密钥lqreqc4245mrqce解密数据dcd68ede7e16fc62
						Sr::decrypt('dcd68ede7e16fc62');
						//2.使用密钥abcd解密数据1b5a0f72ba677d69
						Sr::decrypt('1b5a0f72ba677d69','abcd');
						//3.使用入口文件设置的密钥lqreqc4245mrqce+用户密钥99999解密数据33b01a9262e4ccec
						//最终解密使用的就是密钥：lqreqc4245mrqce99999
						Sr::decrypt('33b01a9262e4ccec','99999',true);
                                        </pre>
                                </li>
                        </ol>
                </fieldset>
                <script src="js/inc.foot.js"></script>
        </body>
</html>
