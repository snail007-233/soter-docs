<!DOCTYPE html>
<html>
	<head>
		<title>数据库手册</title>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<script src="js/inc.js"></script>
	</head>
	<body>
		<fieldset>
			<legend>数据库手册</legend>
			<ol>
				<li>
					<h2 class="title_h2">Soter数据库功能说明</h2>
					Soter数据库驱动主要特点：
					<br>1.支持多主多从，可以设置多个主数据库和多个从数据库,主数据库之间看用户自己情况保持数据一致即可。主之间数据保持一致可以配置主主之间相互主从，或者使用<b>MariaDB Galera Cluster</b>主集群。（原理：所有的读都在随机选取的一个从上面进行，所有的写都在主组上进行）
					<br>2.多主多从模式下也支持事务（原理：事务模式下，所有的读写操作都在主组上进行，主组有一个事务失败，主组全部回滚事务）
					<br>3.支持慢查询记录，支持用户自定义处理类记录慢查询，是把查询语句写到数据库还是发到远程用户完全可以自定义。
					<br>4.支持查询索引分析，自动记录不满足设置的索引的查询。此功能只对MySQL有效。
					<br>原理是通过explain查询语句，检查结果中的type值，值从好到坏依次是:
					<br>system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL，
					ALL意味着全表扫描了，Soter默认级别是index，意思就是如果explain查询type是index之后的时候会记录这个查询。
					<br>支持用户自定义处理类处理不满足索引条件的查询。
					<br>5.支持批量更新，批量插入，批量replace。大幅度提升程序性能。
					<br>6.支持便捷的ActiveRecord链式数据库查询。
					<br>7.支持数据库查询缓存，大幅度减少缓存数据库查询结果数据的编码，Soter里面只需要查询的时候加上一个<code>->cache($cacheTime,$cacheKey='')</code>,
					<br>那么这个查询就具有了缓存的功能，用户无需关心缓存的获取和存储。方法中用户可以省略缓存kye参数，Soter会自动使用md5(sql语句)作为缓存key。
					<br>另外支持自定义缓存处理类用来处理数据库缓存数据。
				</li>

				<li>
					<h2 class="title_h2">数据库配置信息说明</h2>
					连接数据库的配置信息文件默认是在：<code>application/config/default/database.php</code>
					打开这个文件我们可以看到一个数据库信息配置的数组，每部分的说明，会在下面继续详细说明。
					<br>完整配置如下：
					<pre class="brush:php">
						&lt;?php
						//数据库配置文件，文件名默认是database.php,
						//也可以通过在入口文件里面修改配置：
						//->setDatabseConfigFile('database')
						//把里面的database参数修改为你想要的配置文件名即可
						return array(
						    //默认组
						    'default_group' => 'mysql',
						    //组名=>配置
						    //mysql配置示例
						    'mysql' => array(
								'driverType' => 'mysql',
								'debug' => true,
								'pconnect' => false,
								'charset' => 'utf8',
								'collate' => 'utf8_general_ci',
								'database' => '',
								'tablePrefix' => '',
								'tablePrefixSqlIdentifier' => '_tablePrefix_',
								//是否开启慢查询记录
								'slowQueryDebug' => false,
								'slowQueryTime' => 3000, //慢查询最小时间,单位毫秒，1秒=1000毫秒
								'slowQueryHandle' => new Soter_Database_SlowQuery_Handle_Default(),
								/**
								 * 是否开启没有满足设置的索引类型的查询记录
								 */
								'indexDebug' => false,
								/**
								 * 索引使用的最小情况，只有小于最小情况的时候才会记录sql到日志
								 * minIndexType值从好到坏依次是:
								 * system > const > eq_ref > ref > fulltext > ref_or_null 
								 * > index_merge > unique_subquery > index_subquery > range 
								 * > index > ALL 一般来说，得保证查询至少达到range级别，最好能达到ref
								 * 避免ALL即全表扫描
								 */
								'minIndexType' => 'index',
								'indexHandle' => new Soter_Database_Index_Handle_Default(),
								'masters' => array(
									'master01' => array(
									    'hostname' => '127.0.0.1',
									    'port' => 3306,
									    'username' => 'root',
									    'password' => '',
									)
								),
								'slaves' => array(
								//		    'slave01' => array(
								//			'hostname' => '127.0.0.1',
								//			'port' => 3306,
								//			'username' => 'root',
								//			'password' => '',
								//		    )
								)
						    ),
						    //sqlite3配置示例
						    'sqlite3' => array(
									'driverType' => 'sqlite',
									'debug' => true,
									'pconnect' => false,
									'tablePrefix' => '',
									'tablePrefixSqlIdentifier' => '_tablePrefix_',
									//是否开启慢查询记录
									'slowQueryDebug' => true,
									'slowQueryTime' => 3000, //单位毫秒，1秒=1000毫秒
									'slowQueryHandle' => new Soter_Database_SlowQuery_Handle_Default(),
									'masters' => array(
										'master01' => array(
										    'hostname' => 'test.sqlite3', //sqlite3数据库路径
										)
									),
									'slaves' => array(
									//		    'slave01' => array(
									//		    )
									)
								    )
							)
						;
					</pre>  
				</li>
				<li><h3 class="title_h2">数据库配置数组结构</h3>
					在database.php配置文件中我们看到的一个大数组，这个数组就是数据库信息，由几大模块组成。
					<br>下面进行详细说明：
					<br><h3 class="title_h3">1.默认数据库组说明</h3>
					首先是最重要的一个，默认使用的数据库组,对应的配置如下，已经省略无关的配置。
					<pre class="brush:php">
						 //默认组
						'default_group' => 'mysql',
						//组名=>配置
						//mysql配置示例
						'mysql' => array(
							...
						),
						//sqlite3配置示例
						'sqlite' => array(
							...
						),
					</pre>
					可以看到有两个数据库组配置，一个是<b>mysql</b>，一个是<b>sqlite</b>，它们都作为配置数组的一个键名称。
					<br><code>default_group</code>就是告诉Stoer在我们使用Sr::db()不传递参数的时候，默认使用哪一组配置。
					<br><h3 class="title_h3">2.Mysql配置组说明</h3>
					在<b>mysql</b>配置组里面我们可以看到下面的一些公用配置。
					<pre class="brush:php">
						'driverType' => 'mysql',
						'debug' => true,
						'pconnect' => false,
						'charset' => 'utf8',
						'collate' => 'utf8_general_ci',
						'database' => '',
						'tablePrefix' => '',
						'tablePrefixSqlIdentifier' => '_tablePrefix_',
						'masters' => array(
							'master01' => array(
							'hostname' => '127.0.0.1',
							'port' => 3306,
							'username' => 'root',
							'password' => '',
							)
						),
						'slaves' => array(
						//          'slave01' => array(
						//          'hostname' => '127.0.0.1',
						//          'port' => 3306,
						//          'username' => 'root',
						//          'password' => '',
						//          )
						)
					</pre>
					下面对上面每一个配置进行说明：
					<br>1.<b>driverType</b>
					<br>作用：告诉Soter这是一个什么类型的数据库配置，以便Soter正确的初始化数据库连接。
					<br>值：mysql 固定不变。
					<br>2.<b>debug</b>
					<br>作用：告诉Soter发生数据库错误的时候，是否报告错误信息。
					<br>值：ture开启数据库错误报告，false关闭数据库错误报告。
					<br>提示：如果我们在代码中临时需要“有意的”进行一些错误查询，同过判断错误信息，达到一些目的时候。
					<br>我们可以通过Sr::db()->setDebug(false)关闭数据库错误报告，
					<br>然后进行“有意的”错误查询，可以通过Sr::db()->error()获取错误信息字符串。
					<br>最后再Sr::db()->setDebug(true)开启即可。
					<div style="color:red">
						另外：debug为true的时候，只是报告错误给Soter，
						<br>Soter是否显示这个错误是由口文件里面设置的setShowError决定的，
						<br>setShowError是true的时候才会显示错误信息。
					</div>
					使用场景之一：
					<br>需求：比如我们设计了一个SQL学习的网站，用户可以执行sql，返回数据库错误信息。
					<br>我们的程序应该大概是这个样子：
					<pre class="brush:php">
						...
						$sql=Sr::post('sql');
						Sr::db()->setDebug(false);
						if(!Sr::db()->execute($sql)){
							echo Sr::db()->error();
						}
						Sr::db()->setDebug(true);
						...
					</pre>
					<br>上面的代码接受了浏览器post过来的$sql语句，
					<br>然后关闭数据库错误报告，
					<br>执行sql如果出错就显示具体的错误信息。
					<br>最后开启数据库错误报告，继续下面的逻辑。
					<br>3.<b>pconnect</b>
					<br>作用：告诉Soter连接数据库的时候，是否采用持久连接。
					<br>值：ture采用持久连接，false不采用持久连接。
					<br>4.<b>charset</b>
					<br>作用：连接数据库使用的编码。
					<br>值：数据库支持的编码，常见的有utf8 , gbk。
					<br>5.<b>collate</b>
					<br>作用：连接数据库使用的collate编码。
					<br>值：数据库支持的collate编码，常见的有utf8_general_ci,utf8mb4_general_ci。
					<br>6.<b>database</b>
					<br>作用：告诉Soter连接到哪个数据库。
					<br>值：数据库名称。
					<br>7.<b>tablePrefix</b>
					<br>作用：告诉Soter数据库查询的时候，在表名称前面加上的前缀。
					<br>值：数据库表前缀，没有前缀留空即可。
					<br>8.<b>tablePrefixSqlIdentifier</b>
					<br>作用：当我们使用ActiveRecord模式链式查询数据库的时候，
					<br>Soter能够自动在表名称前面加上我们设置的表前缀。
					<br>但是当我们直接执行自定义的sql语句的时候，Soter是无法知道在sql语句字符串里面哪里需要加上表前缀。
					<br>为了避免我们自己手动加前缀，适应数据库表前缀变化，那么我们就可以在sql语句里面需要加上表前缀的地方
					<br>插入一个“占位字符串”这个占位字符串就是tablePrefixSqlIdentifier的值，这样一来，当我们执行自定义sql语句的时候，
					<br>Soter会把sql语句里面出现“占位字符串”替换成表前缀。
					<br>值：默认是_tablePrefix_，可以设置为用户想用的。
					<br>使用实例：
					<br>需求：数据库配置里面配置了表前缀“test_”，tablePrefixSqlIdentifier配置的是_tablePrefix_
					<br>现在自定义一个sql语句查询，不用ActiveRecord模式链式查询。又不想手动加表前缀在sql语句里面。
					<br>代码如下：
					<pre class="brush:php">
						$sql="select * from _tablePrefix_user";
						Sr::db()->execute($sql);
					</pre>
					上面代码中，Soter执行$sql之前，会把$sql里面的_tablePrefix_user替换成test_user，
					<br>这样我们就不用手动加上表前缀，保证了代码的通用性可移植性。
					<br>9.<b>masters</b>
					<br>masters是让我们设置我们有哪些主数据库要用，可以有一个或者多个。
					<br>设置的时候为每个数据库主机指定一个数组key就行，这样能够让Soter区分出不懂的主机。
					<br>上面的<b>master01</b>就是一个key，我们也可以把它叫做master001。
					<br>有多个主数据库的时候，类比master01加在master01下面就行了。
					<br>有两个主数据库的时候，配置实例：
					<pre class="brush:php">
							...
						'masters' => array(
								'master01' => array(
								    'hostname' => '192.168.233.2',
								    'port' => 3306,
								    'username' => 'root',
								    'password' => 'test',
								),
								'master02' => array(
								    'hostname' => '192.168.233.3',
								    'port' => 3306,
								    'username' => 'root',
								    'password' => 'test',
								)
						    ),
							...
					</pre>
					<b style="color: red;">当我们只有一个数据库的时候，设置一个master就可以了。slaves保留空就行了。</b>
					<br>10.<b>slaves</b>
					<br>slaves是让我们设置我们有哪些从数据库要用，可以有一个或者多个。
					<br>设置的时候为每个数据库主机指定一个数组key就行，这样能够让Soter区分出不懂的主机。
					<br>上面的<b>slave01</b>就是一个key，我们也可以把它叫做slave001。
					<br>有多个从数据库的时候，类比slave01加在slave01下面就行了。
					<br>有两个从数据库的时候，配置实例：
					<pre class="brush:php">
							...
						'slaves' => array(
								'slave01' => array(
								    'hostname' => '192.168.233.2',
								    'port' => 3306,
								    'username' => 'root',
								    'password' => 'test',
								),
								'slave02' => array(
								    'hostname' => '192.168.233.3',
								    'port' => 3306,
								    'username' => 'root',
								    'password' => 'test',
								)
						    ),
							...
					</pre>
					<h3 class="title_h3">2.SQLite配置组说明</h3>
					SQLite配置和Mysql基本相同，可以参考mysql配置部分的说明，这里不再重复说明。
					<br>不同的地方是：
					<br>1.主从数据库里使用hostname指定数据库文件位置。
					<br>2.不支持记录不满足条件索引的查询。
					<br>3.组名是sqlite
					<br>4.不支持pconnect，charset，collate设置
				</li>

				<li><h2 class="title_h2">配置中自定义处理类的使用说明</h2>
					上面介绍中说了，Soter支持：
					<br>1.自定义慢查询记录处理类。
					<br>2.自定义不满足设置的索引条件的查询处理类。
					<br>3.自定义数据库缓存数据的缓存处理类。
					<br>下面对这三个类的自定义过程进行说明：
					<h3 class="title_h3">1.自定义慢查询记录处理类</h3>
					配置中我们看到下面三行和慢查询有关的配置。
					<pre class="brush:php">
						//是否开启慢查询记录
						'slowQueryDebug' => false,
						'slowQueryTime' => 3000, //慢查询最小时间,单位毫秒，1秒=1000毫秒
						'slowQueryHandle' => new Soter_Database_SlowQuery_Handle_Default(),
					</pre>
					你会注意到，<code>slowQueryHandle</code>默认使用了<code>Soter_Database_SlowQuery_Handle_Default</code>类处理慢查询，
					<br>它会把慢查询都写入到文件<code>application/storage/slow-query-debug/slow-query-debug.php</code>以便我们分析，
					<br>这个类实现了<code>Soter_Database_SlowQuery_Handle</code>这个接口，然后就能在这里处理慢查询了，
					<br>接下来就是知道怎么实现<code>Soter_Database_SlowQuery_Handle</code>接口，我们就可以写自己的慢查询处理类处理慢查询了。
					<br>首先我们看一下接口的定义代码：
					<pre class="brush:php">
						interface Soter_Database_SlowQuery_Handle {

							public function handle($sql, $explainString, $time);
						}
					</pre>
					可以看到接口就定义了一个handle()方法，有三个参数：
					<br>第一个是慢查询的sql语句字符串。
					<br>第二个是explain查询得到的字符串信息。
					<br>第三个是这次查询使用的时间。
					<br>接下来就是写一个自己的类实现这个接口，把类文件放到合适的位置即可。
					<br>现在我们实现一个简单的显示出慢查询的自定义类。
					<br>步骤如下：
					<br>1.新建一个文件<code>application/classes/SlowQuery/Handle.php</code>
					<br>2.输入下面代码，其实就是定义了一个类，实现接口并简单的显示出慢查询。
					<pre class="brush:php">
						class SlowQuery_Handle implements Soter_Database_SlowQuery_Handle {

							public function handle($sql, $explainString, $time) {
								$content = "\nSQL : " . $sql
									. "\nExplain : " . $explainString
									. "\nUsingTime : " . $time . " ms"
									. "\nTime : " . date('Y-m-d H:i:s') . "\n";
								echo $content;
							}

						}
					</pre>
					3.到此为止我们的自定义处理类搞定了，我们为了测试你可以:
					<br>把<b>slowQueryDebug</b>设置为<b>true</b>。
					<br>把慢查询时间<b>slowQueryTime</b>改成<b>1</b>。
					<br>把<b>slowQueryHandle</b>设置为<b>new SlowQuery_Handle()</b>。
					<br>然后在控制器里面执行一个查询，刷新几次我们会发现显示出自定义类输出的内容。
					<h3 class="title_h3">2.自定义不满足设置的索引条件的查询处理类</h3>
					配置中我们看到下面三行和不满足索引条件的查询处理类有关的配置。
					<pre class="brush:php">
						'indexDebug' => false,
						'minIndexType' => 'index',
						'indexHandle' => new Soter_Database_Index_Handle_Default(),
					</pre>
					你会注意到，<code>indexHandle</code>默认使用了<code>Soter_Database_Index_Handle_Default</code>类处理不满足索引条件的查询，
					<br>它会把不满足设置的索引条件的查询都写入到文件<code>application/storage/index-debug/index-debug.php</code>以便我们分析，
					<br>这个类实现了<code>Soter_Database_Index_Handle</code>这个接口，然后就能在这里处理慢查询了，
					<br>接下来就是知道怎么实现<code>Soter_Database_Index_Handle</code>接口，我们就可以写自己的不满足设置的索引条件的查询处理类处理查询了。
					<br>首先我们看一下接口的定义代码：
					<pre class="brush:php">
						interface Soter_Database_Index_Handle {

							public function handle($sql, $explainString, $time);
						}
					</pre>
					可以看到接口就定义了一个handle()方法，有三个参数：
					<br>第一个是慢查询的sql语句字符串。
					<br>第二个是explain查询得到的字符串信息。
					<br>第三个是这次查询使用的时间。
					<br>接下来就是写一个自己的类实现这个接口，把类文件放到合适的位置即可。
					<br>现在我们实现一个简单的显示出不满足设置的索引条件的查询的自定义类。
					<br>步骤如下：
					<br>1.新建一个文件<code>application/classes/BadIndexQuery/Handle.php</code>
					<br>2.输入下面代码，其实就是定义了一个类，实现接口并简单的显示出慢查询。
					<pre class="brush:php">
						class BadIndexQuery_Handle implements Soter_Database_Index_Handle {

							public function handle($sql, $explainString, $time) {
								$content = "\nSQL : " . $sql
									. "\nExplain : " . $explainString
									. "\nUsingTime : " . $time . " ms"
									. "\nTime : " . date('Y-m-d H:i:s') . "\n";
								echo $content;
							}

						}
					</pre>
					3.到此为止我们的自定义处理类搞定了，我们为了测试，可以自己手动建立一个表，然后不建立索引。
					<br>把<b>indexDebug</b>设置为<b>true</b>。
					<br>把<b>indexHandle</b>设置为<b>new BadIndexQuery_Handle()</b>。
					<br>然后在控制器里面执行搜索所有数据的查询，访问一下我们会发现显示出自定义类输出的内容。
					<h3 class="title_h3">3.自定义数据库缓存数据的缓存处理类</h3>
					数据库缓存操作使用的是入口文件里面配置的程序使用的缓存处理类，配置位于入口文件index.php里面，
					<br>在入口文件里面我们看到下面这个一行：
					<pre class="brush:php">
						//设置缓存类型
						->setCacheHandle(new Soter_Cache_File(SOTER_APP_PATH . 'storage/cache/'))
					</pre>
					这个就是配置程序中使用的缓存处理类，可以看到默认使用的是Soter提供的文件缓存处理类<code>Soter_Cache_File</code>,
					<br>它会把缓存数据写到<code>application/storage/cache/</code>目录下面。
					<br>关于如何自定义缓存处理类，可以参考手册<a href="cache.html">缓存部分</a>。
				</li>

			</ol>

		</fieldset>
		<script src="js/inc.foot.js"></script>
	</body>
</html>
